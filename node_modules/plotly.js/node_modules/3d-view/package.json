{
  "name": "3d-view",
  "version": "2.0.0",
  "description": "3D camera view controller",
  "main": "view.js",
  "scripts": {
    "test": "tape test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mikolalysenko/3d-view.git"
  },
  "keywords": [
    "3d",
    "view",
    "camera",
    "controller"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/mikolalysenko/3d-view/issues"
  },
  "homepage": "https://github.com/mikolalysenko/3d-view",
  "devDependencies": {
    "bunny": "^1.0.1",
    "canvas-fit": "^1.2.0",
    "gl-axes": "^6.0.2",
    "gl-context": "^0.1.1",
    "gl-mat4": "^1.1.2",
    "gl-simplicial-complex": "^3.0.2",
    "right-now": "^1.0.0",
    "tape": "^4.0.0"
  },
  "dependencies": {
    "matrix-camera-controller": "^2.1.1",
    "orbit-camera-controller": "^4.0.0",
    "turntable-camera-controller": "^3.0.0"
  },
  "readme": "3d-view\n=======\nThis module is a generic interface which synchronizes several existing view interactions\n\n* [turntable-camera-controller](https://github.com/mikolalysenko/turntable-camera-controller)\n* [orbit-camera-controller](https://github.com/mikolalysenko/orbit-camera-controller)\n* [matrix-camera-controller](https://github.com/mikolalysenko/orbit-camera-controller)\n\nEach camera controller proceeds by appending events onto a log.  The current camera state is obtained by interpolating between these events.\n\n# API\n\n[Try a more complete demo here](https://mikolalysenko.github.io/3d-view)\n\n```javascript\nvar now            = require('right-now')\nvar bunny          = require('bunny')\nvar perspective    = require('gl-mat4/perspective')\nvar fit            = require('canvas-fit')\nvar createContext  = require('gl-context')\nvar createAxes     = require('gl-axes')\nvar createMesh     = require('gl-simplicial-complex')\nvar createCamera   = require('3d-view')\n\n//Set up WebGL\nvar canvas = document.createElement('canvas')\ndocument.body.appendChild(canvas)\nwindow.addEventListener('resize', fit(canvas), false)\nvar gl = createContext(canvas, {}, render)\n\n//Create objects for rendering\nvar bounds = [[-10,-10,-10], [10,10,10]]\nvar mesh = createMesh(gl, {\n    cells: bunny.cells,\n    positions: bunny.positions,\n    colormap: 'jet'\n  })\nvar axes = createAxes(gl, {\n    bounds: bounds,\n    tickSpacing: [1,1,1],\n    textSize: 0.05\n  })\n\n//Set up camera\nvar projectionMatrix = new Array(16)\nvar camera = createCamera({\n  center:  [\n    0.5*(bounds[0][0]+bounds[1][0]),\n    0.5*(bounds[0][1]+bounds[1][1]),\n    0.5*(bounds[0][2]+bounds[1][2]) ],\n  eye: [0, 0, bounds[1][2]],\n  distanceLimits: [1, 1000]\n})\n\n//Create mode drop down\nvar modeSelect = document.createElement('select')\ncamera.modes.forEach(function(mode) {\n  modeSelect.add(new Option(mode, mode))\n})\nmodeSelect.style.position = 'absolute'\nmodeSelect.style.left = '10px'\nmodeSelect.style.top = '10px'\nmodeSelect.style['z-index'] = 10\ndocument.body.appendChild(modeSelect)\n\n\n//Hook event listeners\nvar lastX = 0, lastY = 0\n\ndocument.oncontextmenu = function(e) { \n  e.preventDefault()\n  e.stopPropagation()\n  return false \n}\n\nmodeSelect.addEventListener('change', function(ev) {\n  camera.setMode(modeSelect.value)\n})\n\ncanvas.addEventListener('mousemove', function(ev) {\n  var dx =  (ev.clientX - lastX) / gl.drawingBufferWidth\n  var dy = -(ev.clientY - lastY) / gl.drawingBufferHeight\n  if(ev.which === 1) {\n    if(ev.shiftKey) {\n      //zoom\n      camera.rotate(now(), 0, 0, dx)\n    } else {\n      //rotate\n      camera.rotate(now(), dx, dy)\n    }\n  } else if(ev.which === 3) {\n    //pan\n    camera.pan(now(), dx, dy)\n  }\n  lastX = ev.clientX\n  lastY = ev.clientY\n})\n\ncanvas.addEventListener('wheel', function(e) {\n  camera.pan(now(), 0, 0, e.deltaY)\n})\n\n//Redraw frame\nfunction render() {\n\n  //Update camera parameters\n  var t = now()\n  camera.idle(t - 20)\n  camera.flush(t - 100)\n  camera.recalcMatrix(t-25)\n  \n  //Compute parameters\n  var cameraParams = {\n    view: camera.computedMatrix,\n    projection: perspective(\n      [],\n      Math.PI/4.0,\n      gl.drawingBufferWidth/gl.drawingBufferHeight,\n      0.1,\n      1000.0)\n  }\n\n  //Draw everything\n  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)\n  gl.enable(gl.DEPTH_TEST)\n  axes.draw(cameraParams)\n  mesh.draw(cameraParams)\n}\n```\n\n## Constructor\n\n#### `var camera = require('3d-view')([options])`\n\n## Methods\n\n#### `camera.idle(t)`\nIdles the camera at time `t`\n\n* `t` is the time to idle at\n\n#### `camera.flush(t)`\nFlush all events in camera state before time `t`\n\n* `t` is the cut off time for the flush\n\n#### `camera.modes`\nAn array of modes supported by the camera\n\n#### `camera.setMode(mode)`\nSets the camera mode\n\n* `mode` is the new mode.  Must be either `turntable`, `orbit` or `matrix`\n\n#### `camera.getMode()`\nRetrieves the current camera mode\n\n#### `camera.lookAt(t, eye, center, up)`\nReset camera position to focus on a specified target\n\n* `t` is the time of the event\n* `eye` is the position of the camera\n* `center` is the target of the camera\n* `up` is a vector pointing up\n\n#### `camera.rotate(t, yaw, pitch, roll)`\nRotates the camera incrementally by some amount\n\n* `t` is the time of the input event\n* `yaw` is the amount to rotate by along y-axis in radians\n* `pitch` is the amount to rotate by along x-axis in radians\n* `roll` is the amount to rotate by along z-axis in radians\n\n#### `camera.pan(t, dx, dy, dz)`\nPans the camera in local (view relative) coordinates\n\n* `t` is the time of the event\n* `dx,dy,dz` is the amount to move\n\n#### `camera.translate(t, dx, dy, dz)`\nTranslates the camera in world (absolute global) coordinates\n\n* `t` is the time of the event\n* `dx,dy,dz` is the amount to move\n\n#### `camera.setMatrix(t, matrix)`\nSets the camera matrix to some fixed 4x4 matrix\n\n* `t` is the time of the event\n* `matrix` is the new camera matrix\n\n#### `camera.setDistance(t, r)`\nSets camera distance at time `t`\n\n* `t` is the time of the event\n* `r` is the new camera distance\n\n#### `camera.setDistanceLimits(lo, hi)`\nSets bounds on the camera distance\n\n#### `camera.getDistanceLimits([out])`\nRetrieves the camera limits\n\n#### `camera.recalcMatrix(t)`\nRecomputes all matrix properties at time `t`\n\n#### `camera.computedMatrix`\nThe computed 4x4 matrix of the camera\n\n#### `camera.computedEye`\nThe computed 3d eye vector for the camera\n\n#### `camera.computedUp`\nComputed up vector (initialized when calling recalcMatrix)\n\n#### `camera.computedCenter`\nComputed camera center point\n\n#### `camera.computedRadius`\nComputed log(radius)\n\n# License\n(c) 2015 Mikola Lysenko. MIT License",
  "readmeFilename": "README.md",
  "_id": "3d-view@2.0.0",
  "dist": {
    "shasum": "2e1dccafd122aa6423521595736f2ca32f02bf10"
  },
  "_from": "3d-view@^2.0.0",
  "_resolved": "https://registry.npmjs.org/3d-view/-/3d-view-2.0.0.tgz"
}
