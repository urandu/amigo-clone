{
  "name": "gl-texture2d",
  "version": "2.0.12",
  "description": "WebGL texture wrapper",
  "main": "texture.js",
  "directories": {
    "example": "example"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "beefy --open example/example.js -- --transform glslify"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/stackgl/gl-texture2d.git"
  },
  "keywords": [
    "webgl",
    "texture",
    "wrap",
    "ndarray"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "0d66ce40f2e25b0715689758e9a659f6544f9f3e",
  "bugs": {
    "url": "https://github.com/stackgl/gl-texture2d/issues"
  },
  "devDependencies": {
    "a-big-triangle": "^1.0.0",
    "baboon-image": "^1.0.0",
    "gl-now": "^1.3.1",
    "gl-shader": "^4.0.1",
    "glslify": "^1.4.0"
  },
  "dependencies": {
    "ndarray": "^1.0.15",
    "ndarray-ops": "^1.2.2",
    "typedarray-pool": "^1.1.0"
  },
  "readme": "gl-texture2d\n============\nWebGL texture object wrapper\n\n# Example\n\n[Try it in your browser right now](http://stackgl.github.io/gl-texture2d/)\n\n```javascript\nvar shell         = require(\"gl-now\")()\nvar createShader  = require(\"gl-shader\")\nvar createTexture = require(\"gl-texture2d\")\nvar drawTriangle  = require(\"a-big-triangle\")\nvar baboon        = require(\"baboon-image\")\nvar glslify       = require(\"glslify\")\n\nvar createShader = glslify({\n  vertex:\"\\\n    attribute vec2 position;\\\n    varying vec2 texCoord;\\\n    void main() {\\\n      gl_Position = vec4(position, 0, 1);\\\n      texCoord = vec2(0.0,1.0)+vec2(0.5,-0.5) * (position + 1.0);\\\n    }\", \n  fragment: \"\\\n    precision highp float;\\\n    uniform sampler2D texture;\\\n    varying vec2 texCoord;\\\n    void main() {\\\n      gl_FragColor = texture2D(texture, texCoord);\\\n    }\",\n  inline: true\n})\n\nvar shader, texture\n\nshell.on(\"gl-init\", function() {\n  var gl = shell.gl\n  \n  //Create texture\n  texture = createTexture(gl, baboon)\n\n  //Create shader\n  shader = createShader(gl)\n  shader.attributes.position.location = 0\n})\n\nshell.on(\"gl-render\", function() {\n  //Draw it\n  shader.bind()\n  shader.uniforms.texture = texture.bind()\n  drawTriangle(shell.gl)\n})\n```\n\nHere is what it should look like:\n\n<img src=\"https://raw.github.com/mikolalysenko/gl-texture2d/master/screenshot.png\">\n\n# Install\n\n    npm install gl-texture2d\n\n# API\n\n```javascript\nvar createTexture = require(\"gl-texture2d\")\n```\n\n## Constructor\nThere are three basic usage patterns for `createTexture`:\n\n### `var tex = createTexture(gl, shape[, format, type])`\nCreates an unitialized texture with the given dimensions and format\n\n* `shape` is a length 2 array representing the `[width, height]` of the texture\n* `format` (optional) is the format of the texture (default `gl.RGBA`)\n* `type` is the type of texture (default `gl.UNSIGNED_BYTE`)\n\n### `var tex = createTexture(gl, domElement[, format, type])`\nCreates a texture from the given data source.  Where `domElement` is one of the following items:\n\n* An `ImageData` object\n* An `HTMLCanvas` object\n* An `HTMLImage` object\n* An `HTMLVideo` object\n\nAnd `format` is an OpenGL data format or defaults to `gl.RGBA` and `type` is the storage type which defaults to `gl.UNSIGNED_BYTE`\n\n### `var tex = createTexture(gl, array)`\nCreates a texture from an [ndarray](https://github.com/mikolalysenko/ndarray).  The rules for selecting the format and type depend on the shape of the ndarray.  The type of the texture is inferred according to the following rules.  Let:\n\n* `dtype = ndarray.dtype(array)`\n* `shape = array.shape`\n\nThen the rules for `type` and `format` are defined according to the following table:\n\n| `dtype`      | `shape`    | `format`        | `type`                 |\n| ------------ |:----------:|:---------------:|:----------------------:|\n| `float*`     | [w,h]      | LUMINANCE       | FLOAT                  |\n| `float*`     | [w,h,1]    | ALPHA           | FLOAT                  |\n| `float*`     | [w,h,2]    | LUMINANCE_ALPHA | FLOAT                  |\n| `float*`     | [w,h,3]    | RGB             | FLOAT                  |\n| `float*`     | [w,h,4]    | RGBA            | FLOAT                  |\n| `(u)int*`    | [w,h]      | LUMINANCE       | UNSIGNED_BYTE          |\n| `(u)int*`    | [w,h,1]    | ALPHA           | UNSIGNED_BYTE          |\n| `(u)int*`    | [w,h,2]    | LUMINANCE_ALPHA | UNSIGNED_BYTE          |\n| `(u)int*`    | [w,h,3]    | RGB             | UNSIGNED_BYTE          |\n| `(u)int*`    | [w,h,4]    | RGBA            | UNSIGNED_BYTE          |\n\nOther combinations of shape and dtype are invalid and throw an error.\n\n## Texture Methods\n\n### `tex.bind([texUnit])`\nBinds the texture for use.  Basically a short cut for:\n\n```javascript\ngl.activeTexture(gl.TEXTURE0 + texUnit)\ngl.bindTexture(gl.TEXTURE_2D, this.handle)\n```\nIf `texUnit` is not specified then the active texture is not changed.\n\n**Returns** The texture unit the texture is bound to.\n\n### `tex.dispose()`\nDestroys the texture object and releases all of its resources.  Under the hood this is equivalent to:\n\n```javascript\ngl.deleteTexture(this.handle)\n```\n\n### `tex.setPixels(data[, offset, mipLevel])`\nUnpacks `data` into a subregion of the texture.  As before in the constructor `data` can be either an `ndarray`, `HTMLCanvas`, `HTMLImage` or `HTMLVideo` object.  If `data` is an ndarray it must have a compatible format with the initial array layout.\n\n* `offset` is a length 2 array representing the offset into which the pixels will be written in `[x,y]`.  (Default: `[0,0]`)\n* `mipLevel` is the mip level to write to. (Default `0`)\n\nIf `data` is an `ndarray` the same rules as in the constructor are followed for converting the type of the buffer.\n\n### `tex.generateMipmap()`\nGenerates mipmaps for the texture.  This will fail if the texture dimensions are not a power of two.\n\n## Texture Properties\n\n#### `tex.shape`\nAn array representing the dimensions of the texture in `[width, height]`.  Writing to this value will resize the texture and invalidate its contents.  For example, to resize the texture `tex` to the shape `[newWidth, newHeight]` you can do:\n\n```javascript\ntex.shape = [newWidth, newHeight]\n```\n\n#### `tex.wrap`\nTexture wrap around behavior for x/y of the texture.  Used to set/get `[gl.TEXTURE_WRAP_T, gl.TEXTURE_WRAP_S]`.  Defaults to `[gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE]`.  To update this value, write to it with a vector. For example,\n\n```javascript\ntex.wrap = [gl.MIRRORED_REPEAT, gl.REPEAT]\n```\n\nOr you can update it with a single value to set the wrap mode for both axes:\n\n```javascript\ntex.wrap = gl.REPEAT\n```\n\n#### `tex.magFilter`\nMagnification filter.  Used to set/get `gl.TEXTURE_MAG_FILTER`. Defaults to `gl.NEAREST`\n\n#### `tex.minFilter`\nMinification filter. Used to set/get `gl.TEXTURE_MIN_FILTER`. Defaults to `gl.NEAREST`\n\n#### `tex.mipSamples`\nThe number of anisotropic filtering samples to use.  This requires `EXT_texture_filter_anisotropic` to have any effect.  High values will improve mipmap quality, but decrease performance.\n\n## Internals\n\n#### `tex.gl`\nA reference to the WebGL context of the texture.\n\n#### `tex.handle`\nA handle to the underlying texture object.\n\n#### `tex.format`\nThe internal format of the texture.\n\n#### `tex.type`\nThe internal data type of the texture.\n\n# Credits\n(c) 2013-2014 Mikola Lysenko. MIT License\n",
  "homepage": "https://github.com/stackgl/gl-texture2d",
  "_id": "gl-texture2d@2.0.12",
  "_from": "gl-texture2d@^2.0.0"
}
