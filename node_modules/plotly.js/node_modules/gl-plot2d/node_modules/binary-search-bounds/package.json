{
  "name": "binary-search-bounds",
  "version": "2.0.3",
  "description": "Better binary searching",
  "main": "search-bounds.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {},
  "devDependencies": {
    "tape": "^4.0.0"
  },
  "scripts": {
    "test": "tape test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mikolalysenko/binary-search-bounds.git"
  },
  "keywords": [
    "binary",
    "search",
    "bounds",
    "least",
    "lower",
    "greatest",
    "upper"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/mikolalysenko/binary-search-bounds/issues"
  },
  "readme": "binary-search-bounds\n====================\nBinary search on arrays for predecessor, successor and range queries.\n\n### Rationale\n\nThe main reason for using a [binary search](https://en.wikipedia.org/wiki/Binary_search_algorithm) or ordered set data structure instead of a hash map is to support fast predecessor/successor queries.  Besides this library, I am aware of no other modules on npm which implement these semantics (making them effectively useless)!!!  `binary-search-bounds` corrects this sad state of affairs.\n\n## Example\n\n```javascript\n//Import module\nvar bounds = require('binary-search-bounds')\n\n//Create an array\nvar array = [1, 2, 3, 3, 3, 5, 6, 10, 11, 13, 50, 1000, 2200]\n\n//Print all elements in array contained in the interval [3, 50)\nconsole.log(\n  array.slice(\n    bounds.ge(array, 3),\n    bounds.lt(array, 50)))\n\n//Test if array contains the element 4\nconsole.log('indexOf(6)=', bounds.eq(array, 6))\nconsole.log('indexOf(4)=', bounds.eq(array, 4))\n\n//Find the element immediately after 13\nconsole.log('successor of 13 = ', array[bounds.gt(array, 13)])\n\n//Find the element in the array before 4\nconsole.log('predecessor of 4 = ', array[bounds.lt(array, 4)])\n```\n\n#### Output:\n\n```\n[ 3, 3, 3, 5, 6, 10, 11 ]\nindexOf(6)= 6\nindexOf(4)= -1\nsuccessor of 13 =  50\npredecessor of 4 =  3\n```\n\n## Install\nUsing [npm](https://docs.npmjs.com/), you can install the library as follows:\n\n```\nnpm install binary-search-bounds\n```\n\nThis module works great with [browserify](http://browserify.org/) if you want to use it in front end projects.\n\n## API\n\n```javascript\nvar bounds = require('binary-search-bounds')\n```\n\n#### `bounds.lt(array, y[, cmp, lo, hi])`\nReturns the index of the last item in the array `<` y.  This is the same as a predecessor query.\n\n#### `bounds.le(array, y[, cmp, lo, hi])`\nReturns the index of the last item in the array `<=` y.  This is a predecessor query which also returns the item if present.\n\n#### `bounds.gt(array, y[, cmp, lo, hi])`\nReturns the index of the first item in the array `>` y.  This is the same as a successor query.\n\n#### `bounds.ge(array, y[, cmp, lo, hi])`\nReturns the index of the first item in the array `>=` y.  This is a successor query which also returns the item if present.\n\n#### `bounds.eq(array, y[, cmp, lo, hi])`\nReturns an index of some item in the array `== y` or `-1` if the item is not presetn.\n\n### Notes\n\nThe following comments apply to the above methods:\n\n* `cmp` is a comparison function, just like what you would pass to `Array.sort()`\n* `y` will always be the second argument passed to `cmp`, so you can ignore it if you are just binary searching on a predicate.\n* Assumes the array is sorted as would be the case if you called `Array.sort(cmp)` on it\n* If no comparison is passed, assume array is sorted in ascending order (note this is different than the semantics of Array.sort() which converts all entries to strings if you don't pass an argument)\n* `lo` gives a lower bound on the array index to search.  If not specified defaults to 0.\n* `hi` gives an upper bound on the array index to search.  If not specified defaults to `array.length-1`\n* Bouth bounds are inclusive.\n* `bounds.le` and `bounds.lt` will return `lo - 1` if no element is found that `==y`\n* `bounds.ge` and `bounds.gt` will return `hi + 1` if no element is found that `==y`\n* `bounds.eq` will return `-1` if no element matching `y` is found.\n* `bounds.eq` will return the first found item with the given index.  It can be a little faster than the other methods if you just want to find some random match and do not care where it is.\n\n## Credits\n(c) 2013 Mikola Lysenko. MIT License\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/mikolalysenko/binary-search-bounds",
  "_id": "binary-search-bounds@2.0.3",
  "dist": {
    "shasum": "91d6ea8ba5e8a71cbd96d40f3af31d831c8ba3fc"
  },
  "_from": "binary-search-bounds@^2.0.3",
  "_resolved": "https://registry.npmjs.org/binary-search-bounds/-/binary-search-bounds-2.0.3.tgz"
}
